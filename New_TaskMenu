#include <iostream>
#include <string>
#include <sstream>
#include <ctime>
#include <queue>
#include <vector>
#include <ctype.h>
#include <algorithm>

using namespace std;

class Task {
private:
    string title, category, dueDate;
    bool completed;

public:
    Task(string t, string c, string d) : title(t), category(c), dueDate(d) {}

    string getTitle() const { return title; }
    string getCategory() const { return category; }
    string getDueDate() const { return dueDate; }

    bool isExpired() const {
        time_t now = time(nullptr);
        tm* localTime = localtime(&now);
        int currentYear = localTime->tm_year % 100;
        int currentMonth = localTime->tm_mon + 1;
        int currentDay = localTime->tm_mday;

        istringstream iss(dueDate);
        int month, day, year;
        char delimiter;
        if (iss >> month >> delimiter >> day >> delimiter >> year) {
            if (year < currentYear || (year == currentYear && month < currentMonth) ||
                (year == currentYear && month == currentMonth && day < currentDay)) {
                return true;
            }
        }
        return false;
    }

    bool isCompleted() const { return completed; }
    void setCompleted(bool value) { completed = value; }
};

class LinkedList {
public:
    struct Node {
        Task* task;
        Node* next;
    };

    Node* head;
    int count, pendingTaskCount;
    vector<Task*> completedTasks;

public:
    LinkedList() : head(nullptr), count(0), pendingTaskCount(0) {}

    ~LinkedList() {
        Node* current = head;
        while (current != nullptr) {
            Node* temp = current;
            current = current->next;
            delete temp->task;
            delete temp;
            count--;
            pendingTaskCount--;
        }
    }
    
    void addTask(Task* newTask) {
        Node* newNode = new Node;
        newNode->task = newTask;
        newNode->next = nullptr;

        if (head == nullptr) {
            head = newNode;
        } else {
            Node* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = newNode;
        }
        count++;
        updateTaskStatus();
        if (!newTask->isCompleted() && !newTask->isExpired()) {
        pendingTaskCount++; // Increment pendingTaskCount
        }
    }

    void updateTaskStatus() {
        Node* current = head;
        pendingTaskCount = 0;
        completedTasks.clear();

        while (current != nullptr) {
            Task* task = current->task;
            if (!task->isCompleted() && !task->isExpired()) {
                pendingTaskCount++;
            }
            else if (task->isCompleted()) {
                completedTasks.push_back(task);
            }
            current = current->next;
        }
    }

    void sortByDueDate(vector<Task*>& tasks) const{
        sort(tasks.begin(), tasks.end(), [](Task* a, Task* b) {
            return a->getDueDate() < b->getDueDate();
        });
    }

    void displayTasks(const vector<Task*>& tasks) const {
        vector<Task*> sortedTasks;
        Node* current = head;
        while (current != nullptr) {
            Task* task = current->task;
            sortedTasks.push_back(task);
            current = current->next;
        }

        // Sort tasks by due date in descending order
        sort(sortedTasks.begin(), sortedTasks.end(), [](Task* a, Task* b) {
            return a->getDueDate() < b->getDueDate();
        });

        for (Task* task : tasks) {
            // Normalize the due date format
            string dueDate = task->getDueDate();
            size_t firstSlashPos = dueDate.find('/');
            size_t lastSlashPos = dueDate.rfind('/');
            string normalizedDueDate = dueDate;
            if (firstSlashPos != string::npos && lastSlashPos != string::npos && lastSlashPos - firstSlashPos == 2) {
                if (firstSlashPos == 1) {
                    normalizedDueDate.insert(0, "0");
                }
                if (lastSlashPos == 4) {
                    normalizedDueDate.insert(3, "0");
                }
            }

            cout << "[" << normalizedDueDate << "] - " << task->getTitle() << endl;
        }
    }

    vector<Task*> getCompletedTasks() const {
        return completedTasks;
    }

    Task* removeTask(Task* taskToRemove) {
        if (head == nullptr)
            return nullptr;

        if (head->task == taskToRemove) {
            Node* temp = head;
            head = head->next;
            Task* removedTask = temp->task;
            delete temp;
            count--;
            updateTaskStatus(); // Update pendingTaskCount
            return removedTask;
        }

        Node* current = head->next;
        Node* prev = head;
        while (current != nullptr) {
            if (current->task == taskToRemove) {
                prev->next = current->next;
                Task* removedTask = current->task;
                delete current;
                count--;
                updateTaskStatus(); // Update pendingTaskCount
                return removedTask;
            }
            prev = current;
            current = current->next;
        }

        return nullptr;
    }

    int getCount() const { return count; }

    bool isEmpty() const { return count == 0; }
};

// Function prototypes
void displayMenu(int pendingTaskCount);
int getUserChoice();
void createTask(LinkedList& tasks);
vector<Task*> searchTasks(const LinkedList& tasks, int searchChoice, const string& searchTerm);
void searchTask(const LinkedList& tasks);
void updateTask(LinkedList& tasks);
void viewTasks(const LinkedList& tasks);
void about();
bool isValidDate(const string& date);
bool isDatePassed(const string& date);
string getCurrentDate();

int main() {
    LinkedList tasks;
    int choice, pendingTaskCount;

    do {
        displayMenu(tasks.pendingTaskCount);
        choice = getUserChoice();

        switch (choice) {
            case 1:
                createTask(tasks);
                break;
            case 2:
                searchTask(tasks);
                break;
            case 3:
                updateTask(tasks);
                break;
            case 4:
                viewTasks(tasks);
                break;
            case 5:
                about();
                break;
            case 6:
                cout << "Exiting... Thank you!" << endl;
                break;
            default:
                cout << "Invalid choice. Please try again." << endl;
                break;
        }

        cout << endl;
    } while (choice != 6);

    return 0;
}

void displayMenu(int pendingTaskCount) {
    cout << "========= Task Manager =========" << endl;
    cout << "1. Create a new task" << endl;
    cout << "2. Search tasks" << endl;
    cout << "3. Update tasks" << endl;
    cout << "4. View tasks [" << pendingTaskCount << "]" << endl;
    cout << "5. About" << endl;
    cout << "6. Exit" << endl;
    cout << "===============================" << endl;
    cout << "Your choice: ";
}

int getUserChoice() {
    int choice;
    while (true) {
        cin >> choice;

        if (cin.fail()) {
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            cout << "Invalid input. Please enter a valid integer." << endl;
        } else {
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            return choice;
        }
    }
}

void createTask(LinkedList& tasks) {
    string title, category, dueDate;
    tasks.pendingTaskCount++;

    cout << "Enter task title: ";
    getline(cin, title);

    cout << "Enter task category: ";
    getline(cin, category);

    cout << "Enter due date (MM/DD/YY): ";
    getline(cin, dueDate);

    if (!isValidDate(dueDate)) {
        cout << "Invalid date format. Task not created." << endl;
        return;
    }

    if (isDatePassed(dueDate)) {
        cout << "The due date has already passed. Task not created." << endl;
        return;
    }

    Task* newTask = new Task(title, category, dueDate);
    tasks.addTask(newTask);
    cout << "Task created successfully!" << endl;
}

vector<Task*> searchTasks(const LinkedList& tasks, int searchChoice, const string& searchTerm) {
    vector<Task*> matchingTasks;
    LinkedList::Node* current = tasks.head;
    while (current != nullptr) {
        Task* task = current->task;

        switch (searchChoice) {
            case 1: // Title
                if (task->getTitle() == searchTerm)
                    matchingTasks.push_back(task);
                break;
            case 2: // Category
                if (task->getCategory() == searchTerm)
                    matchingTasks.push_back(task);
                break;
            case 3: // Date
                if (task->getDueDate() == searchTerm)
                    matchingTasks.push_back(task);
                break;
            default:
                break;
        }

        current = current->next;
    }

    return matchingTasks;
}

void searchTask(const LinkedList& tasks) {
    cout << "Search by" << endl;
    cout << "1. Title" << endl;
    cout << "2. Category" << endl;
    cout << "3. Date" << endl;
    cout << "Your choice: ";
    int searchChoice;
    cin >> searchChoice;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    switch (searchChoice) {
        case 1: {
            cout << "Title: ";
            string title;
            getline(cin, title);

            vector<Task*> matchingTasks = searchTasks(tasks, 1, title);
            if (!matchingTasks.empty()) {
                cout << "Task/s found:" << endl;
                for (Task* task : matchingTasks) {
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
            } else {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        case 2: {
            cout << "Category: ";
            string category;
            getline(cin, category);

            vector<Task*> matchingTasks = searchTasks(tasks, 2, category);
            if (!matchingTasks.empty()) {
                cout << "Task/s found:" << endl;
                for (Task* task : matchingTasks) {
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
            } else {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        case 3: {
            cout << "[MM/DD/YY] Date: ";
            string date;
            getline(cin, date);

            vector<Task*> matchingTasks = searchTasks(tasks, 3, date);
            if (!matchingTasks.empty()) {
                cout << "Task/s found:" << endl;
                for (Task* task : matchingTasks) {
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
            } else {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        default:
            cout << "Invalid choice. Please try again." << endl;
            break;
    }
}

void updateTask(LinkedList& tasks) {
    if (tasks.pendingTaskCount == 0) {
        cout << "No pending tasks to update." << endl;
        return;
    }

    cout << "Search by" << endl;
    cout << "1. Title" << endl;
    cout << "2. Category" << endl;
    cout << "3. Date" << endl;
    cout << "4. Back" << endl;
    cout << "Your choice: ";
    int searchChoice;
    cin >> searchChoice;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    switch (searchChoice) {
        case 1: {
            cout << "Title: ";
            string title;
            getline(cin, title);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getTitle() == title) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        cout << task->getTitle() << ":" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            } else {
                cout << "1. Mark all completed" << endl;
                cout << "2. Delete all" << endl;
                cout << "3. Back" << endl;
                cout << "Your choice: ";
                int updateChoice;
                cin >> updateChoice;
                cin.ignore(numeric_limits<streamsize>::max(), '\n');

                switch (updateChoice) {
                    case 1: {
                        LinkedList::Node* current = tasks.head;
                        while (current != nullptr) {
                            Task* task = current->task;
                            if (task->getTitle() == title && !task->isCompleted()) {
                                task->setCompleted(true);
                                tasks.removeTask(task);
                            }
                            current = current->next;
                        }
                        cout << "All tasks with the title \"" << title << "\" marked as completed!" << endl;
                        break;
                    }
                    case 2: {
                        LinkedList::Node* current = tasks.head;
                        LinkedList::Node* prev = nullptr;
                        int deletedCount = 0;
                        cout << "This action cannot be undone. Do you want to continue? [Y/N] ";
                        char confirm;
                        cin >> confirm;
                        cin.ignore(numeric_limits<streamsize>::max(), '\n');
                        
                        if (confirm == 'Y' || confirm == 'y') {
                            cout << "Deleting all tasks..." << endl;
                            current = tasks.head;
                            while (current != nullptr) {
                                Task* task = current->task;
                                if (task->getTitle() == title) {
                                    if (prev == nullptr) {
                                        tasks.head = current->next;
                                    } else {
                                        prev->next = current->next;
                                    }
                                    delete current->task;
                                    delete current;
                                    current = prev != nullptr ? prev->next : tasks.head;
                                    tasks.count--;
                                    deletedCount++;
                                } else {
                                    prev = current;
                                    current = current->next;
                                }
                            break;
                            }
                        }
                        cout << "Deleted " << deletedCount << " tasks with the title \"" << title << "\"!" << endl;
                        break;
                    }
                }
                tasks.updateTaskStatus();
            }
            break;
        }
        case 2: {
            cout << "Category: ";
            string category;
            getline(cin, category);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getCategory() == category && !task->isCompleted() && !task->isExpired()) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        cout << task->getCategory() << ":" << endl;
                        found = true;
                    }
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            } else {
                cout << "1. Mark all completed" << endl;
                cout << "2. Delete all" << endl;
                cout << "3. Back" << endl;
                cout << "Your choice: ";
                int updateChoice;
                cin >> updateChoice;
                cin.ignore(numeric_limits<streamsize>::max(), '\n');

                switch (updateChoice) {
                    case 1: {
                        LinkedList::Node* current = tasks.head;
                        while (current != nullptr) {
                            Task* task = current->task;
                            if (task->getCategory() == category && !task->isCompleted()) {
                                task->setCompleted(true);
                            }
                            current = current->next;
                        }
                        cout << "All tasks under the category \"" << category << "\" marked as completed!" << endl;
                        break;
                    }
                    case 2: {
                        LinkedList::Node* current = tasks.head;
                        LinkedList::Node* prev = nullptr;
                        int deletedCount = 0;

                        while (current != nullptr) {
                            Task* task = current->task;
                            if (task->getCategory() == category) {
                                if (prev == nullptr) {
                                    tasks.head = current->next;
                                } else {
                                    prev->next = current->next;
                                }
                                delete current->task;
                                delete current;
                                current = prev != nullptr ? prev->next : tasks.head;
                                tasks.count--;
                                deletedCount++;
                            } else {
                                prev = current;
                                current = current->next;
                            }
                        }

                        cout << "Deleted " << deletedCount << " tasks under the category \"" << category << "\"!" << endl;
                        break;
                    }
                    case 3:
                        // Go back to the main menu
                        break;
                    default:
                        cout << "Invalid choice. Please try again." << endl;
                        break;
                }
                tasks.updateTaskStatus();
            }
            break;
        }
        case 3: {
            cout << "[MM/DD/YY] Date: ";
            string date;
            getline(cin, date);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getDueDate() == date && !task->isCompleted() && !task->isExpired()) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            } else {
                cout << "1. Mark all completed" << endl;
                cout << "2. Delete all" << endl;
                cout << "3. Back" << endl;
                cout << "Your choice: ";
                int updateChoice;
                cin >> updateChoice;
                cin.ignore(numeric_limits<streamsize>::max(), '\n');

                switch (updateChoice) {
                    case 1: {
                        LinkedList::Node* current = tasks.head;
                        while (current != nullptr) {
                            Task* task = current->task;
                            if (task->getDueDate() == date && !task->isCompleted()) {
                                task->setCompleted(true);
                            }
                            current = current->next;
                        }
                        cout << "All tasks due on \"" << date << "\" marked as completed!" << endl;
                        break;
                    }
                    case 2: {
                        LinkedList::Node* current = tasks.head;
                        LinkedList::Node* prev = nullptr;
                        int deletedCount = 0;

                        while (current != nullptr) {
                            Task* task = current->task;
                            if (task->getDueDate() == date) {
                                if (prev == nullptr) {
                                    tasks.head = current->next;
                                } else {
                                    prev->next = current->next;
                                }
                                delete current->task;
                                delete current;
                                current = prev != nullptr ? prev->next : tasks.head;
                                tasks.count--;
                                deletedCount++;
                            } else {
                                prev = current;
                                current = current->next;
                            }
                        }

                        cout << "Deleted " << deletedCount << " tasks due on \"" << date << "\"!" << endl;
                        break;
                    }
                    case 3:
                        // Go back to the main menu
                        break;
                    default:
                        cout << "Invalid choice. Please try again." << endl;
                        break;
                }
                tasks.updateTaskStatus();
            }
            break;
        }
        default:
            cout << "Invalid choice. Please try again." << endl;
            break;
    }
}

void viewTasks(const LinkedList& tasks) {
    LinkedList::Node* current = tasks.head;
    bool foundPendingTasks = false;
    bool foundCompletedTasks = false;
    bool foundExpiredTasks = false;
    int pendingTaskCount = 0;

    vector<Task*> matchingTasks;

    int viewChoice;
    cout << "1. View Pending Tasks" << endl;
    cout << "2. View Completed Tasks" << endl;
    cout << "3. View Expired Tasks" << endl;
    cout << "Your choice: ";
    cin >> viewChoice;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    switch (viewChoice) {
        case 1:
            matchingTasks = searchTasks(tasks, 3, "");
            if (!matchingTasks.empty()) {
                cout << "Pending Tasks:" << endl;
                for (Task* task : matchingTasks) {
                    if (!task->isCompleted()) {
                        cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                        foundPendingTasks = true;
                    }
                }
                if (!foundPendingTasks) {
                    cout << "No pending tasks found." << endl;
                }
            } else {
                cout << "No pending tasks found." << endl;
            }
            break;
        case 2:{
            vector<Task*> completedTasks = tasks.getCompletedTasks();
            if (!completedTasks.empty()) {
                cout << "Completed Tasks:" << endl;
                for (Task* task : completedTasks) {
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
            } else {
                cout << "No completed tasks found." << endl;
            }
            break;
        }
        case 3:
            matchingTasks = searchTasks(tasks, 3, "");
            if (!matchingTasks.empty()) {
                cout << "Expired Tasks:" << endl;
                for (Task* task : matchingTasks) {
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
            } else {
                cout << "No expired tasks found." << endl;
            }
            break;
        default:
            cout << "Invalid choice. Please try again." << endl;
            break;
    }

}

string getCurrentDate() {
    time_t now = time(nullptr);
    tm* localTime = localtime(&now);

    int currentYear = localTime->tm_year % 100;
    int currentMonth = localTime->tm_mon + 1;
    int currentDay = localTime->tm_mday;

    string currentDate = to_string(currentMonth) + "/" + to_string(currentDay) + "/" + to_string(currentYear);
    return currentDate;
}

void about() {
    cout << "Task Manager v1.0" << endl;
    cout << "Developed by [Your Name]" << endl;
    cout << "https://www.example.com" << endl;
}

bool isValidDate(const string& date) {
    istringstream iss(date);
    int month, day, year;
    char delimiter;
    return (iss >> month >> delimiter >> day >> delimiter >> year) ? true : false;
}

bool isDatePassed(const string& date) {
    time_t now = time(nullptr);
    tm* localTime = localtime(&now);
    int currentYear = localTime->tm_year % 100;
    int currentMonth = localTime->tm_mon + 1;
    int currentDay = localTime->tm_mday;

    istringstream iss(date);
    int month, day, year;
    char delimiter;
    if (iss >> month >> delimiter >> day >> delimiter >> year) {
        if (year < currentYear || (year == currentYear && month < currentMonth) ||
            (year == currentYear && month == currentMonth && day < currentDay)) {
            return true;
        }
    }
    return false;
}
