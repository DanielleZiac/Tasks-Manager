#include <iostream>
#include <string>
#include <sstream>
#include <iomanip>
#include <limits>
using namespace std;

// Task class
class Task {
private:
    string title;
    string category;
    string dueDate;
    bool completed;

public:
    Task(string t, string c, string d) {
        title = t;
        category = c;
        dueDate = d;
    }

    string getTitle() const {
        return title;
    }

    string getCategory() const {
        return category;
    }

    string getDueDate() const {
        return dueDate;
    }
        bool isExpired() const {
        // Get the current date
        time_t now = time(nullptr);
        tm* localTime = localtime(&now);
        int currentYear = localTime->tm_year % 100;
        int currentMonth = localTime->tm_mon + 1;
        int currentDay = localTime->tm_mday;

        // Extract the month, day, and year from the due date
        istringstream iss(dueDate);
        int month, day, year;
        char delimiter;
        if (iss >> month >> delimiter >> day >> delimiter >> year) {
            // Compare the due date with the current date
            if (year < currentYear || (year == currentYear && month < currentMonth) ||
                (year == currentYear && month == currentMonth && day < currentDay)) {
                return true; // Task is expired
            }
        }

        return false; // Task is not expired
    }

    bool isCompleted() const {
        return completed; // Assuming you have a bool member variable 'completed' indicating completion status
    }
};

// LinkedList class
class LinkedList {
public:
    struct Node {
        Task* task;
        Node* next;
    };

    Node* head;
    int count;

public:
    LinkedList() {
        head = nullptr;
        count = 0;
    }

    ~LinkedList() {
        Node* current = head;
        while (current != nullptr) {
            Node* temp = current;
            current = current->next;
            delete temp->task;
            delete temp;
        }
    }

    void addTask(Task* newTask) {
        Node* newNode = new Node;
        newNode->task = newTask;
        newNode->next = nullptr;

        if (head == nullptr) {
            head = newNode;
        } else {
            Node* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = newNode;
        }

        count++;
    }

    void displayTasks() const {
        Node* current = head;
        while (current != nullptr) {
            Task* task = current->task;
            cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
            current = current->next;
        }
    }

    int getCount() const {
        return count;
    }

    bool isEmpty() const {
        return count == 0;
    }
};

// Function prototypes
void displayMenu();
int getUserChoice();
void createTask(LinkedList& tasks);
void searchTask(const LinkedList& tasks);
void updateTask(LinkedList& tasks);
void viewTasks(const LinkedList& tasks);
void about();
bool isValidDate(const string& date);
bool isDatePassed(const string& date);

int main() {
    LinkedList tasks;
    int choice;

    do {
        displayMenu();
        choice = getUserChoice();

        switch (choice) {
            case 1:
                createTask(tasks);
                break;
            case 2:
                searchTask(tasks);
                break;
            case 3:
                updateTask(tasks);
                break;
            case 4:
                viewTasks(tasks);
                break;
            case 5:
                about();
                break;
            case 6:
                cout << "Exiting program..." << endl;
                break;
            default:
                cout << "Invalid choice. Please try again." << endl;
                break;
        }

        cout << endl;
    } while (choice != 6);

    return 0;
}

void displayMenu() {
    cout << "[Menu]" << endl;
    cout << "1. Create Tasks" << endl;
    cout << "2. Search Task" << endl;
    cout << "3. Update Task" << endl;
    cout << "4. View Tasks [0]" << endl;
    cout << "5. About" << endl;
    cout << "6. Exit" << endl;
    cout << "Your choice: ";
}

int getUserChoice() {
    int choice;
    cin >> choice;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    return choice;
}

void createTask(LinkedList& tasks) {
    cout << "Enter Task: ";
    string title;
    getline(cin, title);

    cout << "Category: ";
    string category;
    getline(cin, category);

    string dueDate;
    bool validDate = false;
    while (!validDate) {
        cout << "[MM/DD/YY] Due date: ";
        getline(cin, dueDate);

        if (!isValidDate(dueDate)) {
            cout << "Date not valid. Please enter a date in the format MM/DD/YY." << endl;
        } else if (isDatePassed(dueDate)) {
            cout << "Date not valid. The date has passed the current date." << endl;
        } else {
            Task* newTask = new Task(title, category, dueDate);
            tasks.addTask(newTask);
            cout << "Task added successfully!" << endl;
            validDate = true;
        }
    }
}
void searchTask(const LinkedList& tasks) {
    cout << "Search by" << endl;
    cout << "1. Title" << endl;
    cout << "2. Category" << endl;
    cout << "3. Date" << endl;
    cout << "Your choice: ";
    int searchChoice;
    cin >> searchChoice;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    switch (searchChoice) {
        case 1: {
            cout << "Title: ";
            string title;
            getline(cin, title);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getTitle() == title) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        case 2: {
            cout << "Category: ";
            string category;
            getline(cin, category);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getCategory() == category) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        case 3: {
            cout << "[MM/DD/YY] Date: ";
            string date;
            getline(cin, date);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getDueDate() == date) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        default:
            cout << "Invalid choice. Please try again." << endl;
            break;
    }
}

void updateTask(LinkedList& tasks) {
    cout << "Search by" << endl;
    cout << "1. Title" << endl;
    cout << "2. Category" << endl;
    cout << "3. Date" << endl;
    cout << "4. Back" << endl;
    cout << "Your choice: ";
    int searchChoice;
    cin >> searchChoice;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    switch (searchChoice) {
        case 1: {
            cout << "Title: ";
            string title;
            getline(cin, title);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getTitle() == title) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;

                    cout << "1. Mark all completed" << endl;
                    cout << "2. Delete all" << endl;
                    cout << "3. Back" << endl;
                    cout << "Your choice: ";
                    int updateChoice;
                    cin >> updateChoice;
                    cin.ignore(numeric_limits<streamsize>::max(), '\n');

                    switch (updateChoice) {
                        case 1: {
                            cout << "Marking all tasks as completed..." << endl;
                            LinkedList::Node* current = tasks.head;
                            while (current != nullptr) {
                                Task* task = current->task;
                                // Mark the task as completed
                                // ...
                                current = current->next;
                            }
                            cout << "All tasks marked as completed!" << endl;
                            break;
                        }
                        case 2: {
                            cout << "This action cannot be undone. Do you want to continue? [Y/N] ";
                            char confirm;
                            cin >> confirm;
                            cin.ignore(numeric_limits<streamsize>::max(), '\n');
                            if (confirm == 'Y' || confirm == 'y') {
                                cout << "Deleting all tasks..." << endl;
                                LinkedList::Node* current = tasks.head;
                                while (current != nullptr) {
                                    LinkedList::Node* temp = current;
                                    current = current->next;
                                    Task* task = temp->task;
                                    // Delete the task
                                    // ...
                                    delete task;
                                    delete temp;
                                }
                                tasks.head = nullptr;
                                tasks.count = 0;
                                cout << "All tasks deleted!" << endl;
                            }
                            break;
                        }
                        case 3:
                            // Go back to the main menu
                            break;
                        default:
                            cout << "Invalid choice. Please try again." << endl;
                            break;
                    }
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        case 2: {
            cout << "Category: ";
            string category;
            getline(cin, category);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getCategory() == category) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;

                    cout << "1. Mark all completed" << endl;
                    cout << "2. Delete all" << endl;
                    cout << "3. Back" << endl;
                    cout << "Your choice: ";
                    int updateChoice;
                    cin >> updateChoice;
                    cin.ignore(numeric_limits<streamsize>::max(), '\n');

                    switch (updateChoice) {
                        case 1:
                            // Mark all completed code here
                            // ...
                            break;
                        case 2: {
                            cout << "This action cannot be undone. Do you want to continue? [Y/N] ";
                            char confirm;
                            cin >> confirm;
                            cin.ignore(numeric_limits<streamsize>::max(), '\n');
                            if (confirm == 'Y' || confirm == 'y') {
                                // Delete all code here
                                // ...
                            }
                            break;
                        }
                        case 3:
                            // Go back to main menu
                            break;
                        default:
                            cout << "Invalid choice. Please try again." << endl;
                            break;
                    }
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        case 3: {
            cout << "[MM/DD/YY] Date: ";
            string date;
            getline(cin, date);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getDueDate() == date) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;

                    cout << "1. Mark all completed" << endl;
                    cout << "2. Delete all" << endl;
                    cout << "3. Back" << endl;
                    cout << "Your choice: ";
                    int updateChoice;
                    cin >> updateChoice;
                    cin.ignore(numeric_limits<streamsize>::max(), '\n');

                    switch (updateChoice) {#include <iostream>
#include <string>
#include <sstream>
#include <ctime>
#include <queue>
#include <vector>

using namespace std;

class Task {
private:
    string title, category, dueDate;
    bool completed;

public:
    Task(string t, string c, string d) : title(t), category(c), dueDate(d) {}

    string getTitle() const { return title; }
    string getCategory() const { return category; }
    string getDueDate() const { return dueDate; }

    bool isExpired() const {
        time_t now = time(nullptr);
        tm* localTime = localtime(&now);
        int currentYear = localTime->tm_year % 100;
        int currentMonth = localTime->tm_mon + 1;
        int currentDay = localTime->tm_mday;

        istringstream iss(dueDate);
        int month, day, year;
        char delimiter;
        if (iss >> month >> delimiter >> day >> delimiter >> year) {
            if (year < currentYear || (year == currentYear && month < currentMonth) ||
                (year == currentYear && month == currentMonth && day < currentDay)) {
                return true;
            }
        }
        return false;
    }

    bool isCompleted() const { return completed; }
};

class LinkedList {
public:
    struct Node {
        Task* task;
        Node* next;
    };

    Node* head;
    int count, pendingTaskCount;

public:
    LinkedList() : head(nullptr), count(0), pendingTaskCount(0) {}

    ~LinkedList() {
        Node* current = head;
        while (current != nullptr) {
            Node* temp = current;
            current = current->next;
            delete temp->task;
            delete temp;
            count--;
        }
    }

    void addTask(Task* newTask) {
        Node* newNode = new Node;
        newNode->task = newTask;
        newNode->next = nullptr;

        if (head == nullptr) {
            head = newNode;
        } else {
            Node* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = newNode;
        }
        count++;
        updateTaskStatus();
    }

    void updateTaskStatus() {
        Node* current = head;
        int pendingTaskCount = 0;

        while (current != nullptr) {
            Task* task = current->task;
            if (!task->isCompleted() && !task->isExpired()) {
                pendingTaskCount++;
            }
            current = current->next;
        }

        this->pendingTaskCount = pendingTaskCount;
    }

    void displayTasks() const {
        Node* current = head;
        while (current != nullptr) {
            Task* task = current->task;
            cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
            current = current->next;
        }
    }

    int getCount() const { return count; }

    bool isEmpty() const { return count == 0; }
};

// Function prototypes
void displayMenu(int pendingTaskCount);
int getUserChoice();
void createTask(LinkedList& tasks);
void searchTask(const LinkedList& tasks);
void updateTask(LinkedList& tasks);
void viewTasks(const LinkedList& tasks);
void about();
bool isValidDate(const string& date);
bool isDatePassed(const string& date);

int main() {
    LinkedList tasks;
    int choice, pendingTaskCount;

    do {
        displayMenu(tasks.pendingTaskCount);
        choice = getUserChoice();

        switch (choice) {
            case 1:
                createTask(tasks);
                break;
            case 2:
                searchTask(tasks);
                break;
            case 3:
                updateTask(tasks);
                break;
            case 4:
                viewTasks(tasks);
                break;
            case 5:
                about();
                break;
            case 6:
                cout << "Exiting program..." << endl;
                break;
            default:
                cout << "Invalid choice. Please try again." << endl;
                break;
        }

        cout << endl;
    } while (choice != 6);

    return 0;
}

void displayMenu(int pendingTaskCount) {
    cout << "[Menu]" << endl;
    cout << "1. Create Tasks" << endl;
    cout << "2. Search Task" << endl;
    cout << "3. Update Task" << endl;
    cout << "4. View Tasks [" << pendingTaskCount << "]" << endl;
    cout << "5. About" << endl;
    cout << "6. Exit" << endl;
    cout << "Your choice: ";
}

int getUserChoice() {
    int choice;
    cin >> choice;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    return choice;
}

void createTask(LinkedList& tasks) {
    cout << "Enter Task: ";
    string title;
    getline(cin, title);

    cout << "Category: ";
    string category;
    getline(cin, category);

    string dueDate;
    bool validDate = false;
    while (!validDate) {
        cout << "[MM/DD/YY] Due date: ";
        getline(cin, dueDate);

        if (!isValidDate(dueDate)) {
            cout << "Date not valid. Please enter a date in the format MM/DD/YY." << endl;
        } else if (isDatePassed(dueDate)) {
            cout << "Date not valid. The date has passed the current date." << endl;
        } else {
            Task* newTask = new Task(title, category, dueDate);
            tasks.addTask(newTask);
            cout << "Task added successfully!" << endl;
            validDate = true;
        }
    }
}

void searchTask(const LinkedList& tasks) {
    cout << "Search by" << endl;
    cout << "1. Title" << endl;
    cout << "2. Category" << endl;
    cout << "3. Date" << endl;
    cout << "Your choice: ";
    int searchChoice;
    cin >> searchChoice;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    switch (searchChoice) {
        case 1: {
            cout << "Title: ";
            string title;
            getline(cin, title);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getTitle() == title) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        case 2: {
            cout << "Category: ";
            string category;
            getline(cin, category);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getCategory() == category) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        case 3: {
            cout << "[MM/DD/YY] Date: ";
            string date;
            getline(cin, date);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getDueDate() == date) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        default:
            cout << "Invalid choice. Please try again." << endl;
            break;
    }
}

void updateTask(LinkedList& tasks) {
    cout << "Search by" << endl;
    cout << "1. Title" << endl;
    cout << "2. Category" << endl;
    cout << "3. Date" << endl;
    cout << "4. Back" << endl;
    cout << "Your choice: ";
    int searchChoice;
    int pendingTaskCount = 0;
    cin >> searchChoice;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    switch (searchChoice) {
        case 1: {
            cout << "Title: ";
            string title;
            getline(cin, title);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getTitle() == title) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;

                    cout << "1. Mark all completed" << endl;
                    cout << "2. Delete all" << endl;
                    cout << "3. Back" << endl;
                    cout << "Your choice: ";
                    int updateChoice;
                    cin >> updateChoice;
                    cin.ignore(numeric_limits<streamsize>::max(), '\n');

                    switch (updateChoice) {
                        case 1: {
                            cout << "Marking all tasks as completed..." << endl;
                            LinkedList::Node* current = tasks.head;
                            while (current != nullptr) {
                                Task* task = current->task;
                                // Mark the task as completed
                                // ...
                                current = current->next;
                            }
                            cout << "All tasks marked as completed!" << endl;
                            break;
                        }
                        case 2: {
                            cout << "This action cannot be undone. Do you want to continue? [Y/N] ";
                            char confirm;
                            cin >> confirm;
                            cin.ignore(numeric_limits<streamsize>::max(), '\n');
                            if (confirm == 'Y' || confirm == 'y') {
                                cout << "Deleting all tasks..." << endl;
                                LinkedList::Node* current = tasks.head;
                                while (current != nullptr) {
                                    LinkedList::Node* temp = current;
                                    current = current->next;
                                    Task* task = temp->task;
                                    // Delete the task
                                    // ...
                                    delete task;
                                    delete temp;
                                }
                                tasks.head = nullptr;
                                tasks.count = 0;
                                cout << "All tasks deleted!" << endl;
                            }
                            break;
                        }
                        case 3:
                            // Go back to the main menu
                            break;
                        default:
                            cout << "Invalid choice. Please try again." << endl;
                            break;
                    }
                    tasks.updateTaskStatus();
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        case 2: {
            cout << "Category: ";
            string category;
            getline(cin, category);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getCategory() == category) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;

                    cout << "1. Mark all completed" << endl;
                    cout << "2. Delete all" << endl;
                    cout << "3. Back" << endl;
                    cout << "Your choice: ";
                    int updateChoice;
                    cin >> updateChoice;
                    cin.ignore(numeric_limits<streamsize>::max(), '\n');

                    switch (updateChoice) {
                        case 1:
                            // Mark all completed code here
                            // ...
                            break;
                        case 2: {
                            cout << "This action cannot be undone. Do you want to continue? [Y/N] ";
                            char confirm;
                            cin >> confirm;
                            cin.ignore(numeric_limits<streamsize>::max(), '\n');
                            if (confirm == 'Y' || confirm == 'y') {
                                // Delete all code here
                                // ...
                            }
                            break;
                        }
                        case 3:
                            // Go back to main menu
                            break;
                        default:
                            cout << "Invalid choice. Please try again." << endl;
                            break;
                    }
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        case 3: {
            cout << "[MM/DD/YY] Date: ";
            string date;
            getline(cin, date);

            LinkedList::Node* current = tasks.head;
            bool found = false;
            while (current != nullptr) {
                Task* task = current->task;
                if (task->getDueDate() == date) {
                    if (!found) {
                        cout << "Task/s found:" << endl;
                        found = true;
                    }
                    cout << task->getCategory() << ":" << endl;
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;

                    cout << "1. Mark all completed" << endl;
                    cout << "2. Delete all" << endl;
                    cout << "3. Back" << endl;
                    cout << "Your choice: ";
                    int updateChoice;
                    cin >> updateChoice;
                    cin.ignore(numeric_limits<streamsize>::max(), '\n');

                    switch (updateChoice) {
                        case 1:
                            // Mark all completed code here
                            // ...
                            break;
                        case 2: {
                            cout << "This action cannot be undone. Do you want to continue? [Y/N] ";
                            char confirm;
                            cin >> confirm;
                            cin.ignore(numeric_limits<streamsize>::max(), '\n');
                            if (confirm == 'Y' || confirm == 'y') {
                                // Delete all code here
                                // ...
                            }
                            break;
                        }
                        case 3:
                            // Go back to main menu
                            break;
                        default:
                            cout << "Invalid choice. Please try again." << endl;
                            break;
                    }
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        case 4:
            // Go back to main menu
            break;
        default:
            cout << "Invalid choice. Please try again." << endl;
            break;
    }
}

void viewTasks(const LinkedList& tasks) {
    LinkedList::Node* current = tasks.head;
    bool foundPendingTasks = false;
    bool foundCompletedTasks = false;
    bool foundExpiredTasks = false;
    int pendingTaskCount = 0;

    cout << "1. View Pending Tasks" << endl;
    cout << "2. View Completed Tasks" << endl;
    cout << "3. View Expired Tasks" << endl;
    cout << "Your choice: ";
    int viewChoice;
    cin >> viewChoice;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    switch (viewChoice) {
        case 1: {
            cout << "Pending Tasks:" << endl;
            LinkedList::Node* current = tasks.head;
            bool foundPendingTasks = false;
            while (current != nullptr) {
                Task* task = current->task;
                // Check if the task is pending
                // ...
                if (!task->isCompleted() && !task->isExpired()) {
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                    foundPendingTasks = true;
                    pendingTaskCount++;
                }
                current = current->next;
            }
            if (!foundPendingTasks) {
                cout << "No pending tasks found." << endl;
            }
            break;
        }
        case 2: {
            cout << "Completed Tasks:" << endl;
            LinkedList::Node* current = tasks.head;
            bool foundCompletedTasks = false;
            while (current != nullptr) {
                Task* task = current->task;
                // Check if the task is completed
                // ...
                if (task->isCompleted()) {
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                    foundCompletedTasks = true;
                }
                current = current->next;
            }
            if (!foundCompletedTasks) {
                cout << "No completed tasks found." << endl;
            }
            break;
        }
        case 3:
            cout << "Expired Tasks:" << endl;
            // Display expired tasks code here
            while (current != nullptr) {
                Task* task = current->task;
                // Check if the task is expired
                // ...
                if (task->isExpired()) {
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                    foundExpiredTasks = true;
                }
                current = current->next;
            }
            if (!foundExpiredTasks) {
                cout << "No expired tasks found." << endl;
            }
            break;
        default:
            cout << "Invalid choice. Please try again." << endl;
            break;
    }
}

void about() {
    cout << "(information and instructions of this program)" << endl;
}

bool isValidDate(const string& date) {
    istringstream iss(date);
    int month, day, year;
    char delimiter;
    if (iss >> month >> delimiter >> day >> delimiter >> year) {
        if (month >= 1 && month <= 12 && day >= 1 && day <= 31 && year >= 0 && year <= 99) {
            return true;
        }
    }
    return false;
}

bool isDatePassed(const string& date) {
    istringstream iss(date);
    int month, day, year;
    char delimiter;
    if (iss >> month >> delimiter >> day >> delimiter >> year) {
        // Get the current date
        time_t now = time(nullptr);
        tm* localTime = localtime(&now);
        int currentYear = localTime->tm_year % 100;
        int currentMonth = localTime->tm_mon + 1;
        int currentDay = localTime->tm_mday;

        if (year < currentYear || (year == currentYear && month < currentMonth) ||
            (year == currentYear && month == currentMonth && day < currentDay)) {
            return true;
        }
    }
    return false;
}

                        case 1:
                            // Mark all completed code here
                            // ...
                            break;
                        case 2: {
                            cout << "This action cannot be undone. Do you want to continue? [Y/N] ";
                            char confirm;
                            cin >> confirm;
                            cin.ignore(numeric_limits<streamsize>::max(), '\n');
                            if (confirm == 'Y' || confirm == 'y') {
                                // Delete all code here
                                // ...
                            }
                            break;
                        }
                        case 3:
                            // Go back to main menu
                            break;
                        default:
                            cout << "Invalid choice. Please try again." << endl;
                            break;
                    }
                }
                current = current->next;
            }

            if (!found) {
                cout << "Task/s not found." << endl;
            }
            break;
        }
        case 4:
            // Go back to main menu
            break;
        default:
            cout << "Invalid choice. Please try again." << endl;
            break;
    }
}


void viewTasks(const LinkedList& tasks) {
    LinkedList::Node* current = tasks.head;
    bool foundPendingTasks = false;
    bool foundCompletedTasks = false;
    bool foundExpiredTasks = false;

    cout << "1. View Pending Tasks" << endl;
    cout << "2. View Completed Tasks" << endl;
    cout << "3. View Expired Tasks" << endl;
    cout << "Your choice: ";
    int viewChoice;
    cin >> viewChoice;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    switch (viewChoice) {
        case 1: {
            cout << "Pending Tasks:" << endl;
            LinkedList::Node* current = tasks.head;
            bool foundPendingTasks = false;
            while (current != nullptr) {
                Task* task = current->task;
                // Check if the task is pending
                // ...
                if (!task->isCompleted() && !task->isExpired()) {
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                    foundPendingTasks = true;
                }
                current = current->next;
            }
            if (!foundPendingTasks) {
                cout << "No pending tasks found." << endl;
            }
            break;
        }
        case 2: {
            cout << "Completed Tasks:" << endl;
            LinkedList::Node* current = tasks.head;
            bool foundCompletedTasks = false;
            while (current != nullptr) {
                Task* task = current->task;
                // Check if the task is completed
                // ...
                if (task->isCompleted()) {
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                    foundCompletedTasks = true;
                }
                current = current->next;
            }
            if (!foundCompletedTasks) {
                cout << "No completed tasks found." << endl;
            }
            break;
        }
        case 3:
            cout << "Expired Tasks:" << endl;
            // Display expired tasks code here
            while (current != nullptr) {
                Task* task = current->task;
                // Check if the task is expired
                // ...
                if (task->isExpired()) {
                    cout << "[" << task->getDueDate() << "] - " << task->getTitle() << endl;
                    foundExpiredTasks = true;
                }
                current = current->next;
            }
            if (!foundExpiredTasks) {
                cout << "No expired tasks found." << endl;
            }
            break;
        default:
            cout << "Invalid choice. Please try again." << endl;
            break;
    }
}

void about() {
    cout << "(information and instructions of this program)" << endl;
}

bool isValidDate(const string& date) {
    istringstream iss(date);
    int month, day, year;
    char delimiter;
    if (iss >> month >> delimiter >> day >> delimiter >> year) {
        if (month >= 1 && month <= 12 && day >= 1 && day <= 31 && year >= 0 && year <= 99) {
            return true;
        }
    }
    return false;
}

bool isDatePassed(const string& date) {
    istringstream iss(date);
    int month, day, year;
    char delimiter;
    if (iss >> month >> delimiter >> day >> delimiter >> year) {
        // Get the current date
        time_t now = time(nullptr);
        tm* localTime = localtime(&now);
        int currentYear = localTime->tm_year % 100;
        int currentMonth = localTime->tm_mon + 1;
        int currentDay = localTime->tm_mday;

        if (year < currentYear || (year == currentYear && month < currentMonth) ||
            (year == currentYear && month == currentMonth && day < currentDay)) {
            return true;
        }
    }
    return false;
}
